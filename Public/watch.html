<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes, viewport-fit=cover" />
  <title>ZenStream ¬∑ Mobile HLS</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <!-- Video.js for HLS support -->
  <link href="https://vjs.zencdn.net/8.10.0/video-js.css" rel="stylesheet" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      background: #0a0d14;
      color: #e5eaff;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      line-height: 1.4;
      min-height: 100vh;
      padding-bottom: env(safe-area-inset-bottom);
    }

    /* Mobile-first header */
    header {
      background: rgba(18, 26, 40, 0.98);
      backdrop-filter: blur(10px);
      padding: 0.5rem 0.75rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #1f2940;
      position: sticky;
      top: 0;
      z-index: 100;
      gap: 0.5rem;
      height: 56px;
    }

    header a {
      color: #9ab3ff;
      text-decoration: none;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 8px 12px;
      background: #1a253c;
      border-radius: 40px;
      font-size: 0.85rem;
      white-space: nowrap;
      min-width: 44px;
      min-height: 44px;
    }

    #anime-title {
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: capitalize;
      background: linear-gradient(135deg, #fff, #9ab3ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
      text-align: center;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0.75rem;
    }

    /* Player section - HLS only */
    .player-wrapper {
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 16px -4px rgba(0, 0, 0, 0.8);
      border: 1px solid #253553;
      margin-bottom: 0.75rem;
      aspect-ratio: 16/9;
      position: relative;
    }

    .video-js {
      width: 100%;
      height: 100%;
    }

    /* Custom video controls for mobile */
    .vjs-default-skin .vjs-big-play-button {
      width: 60px !important;
      height: 60px !important;
      line-height: 60px !important;
      border-radius: 50% !important;
      left: 50% !important;
      top: 50% !important;
      transform: translate(-50%, -50%) !important;
      background: rgba(61, 99, 255, 0.9) !important;
      border: none !important;
    }

    .vjs-default-skin .vjs-progress-control {
      height: 8px !important;
    }

    .vjs-default-skin .vjs-volume-panel {
      margin-right: 8px !important;
    }

    /* Skip popup - mobile optimized */
    .skip-popup {
      position: absolute;
      bottom: 70px;
      right: 12px;
      background: rgba(61, 99, 255, 0.95);
      backdrop-filter: blur(10px);
      color: white;
      padding: 14px 20px;
      border-radius: 40px;
      font-weight: 600;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.2);
      animation: slideIn 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 1rem;
      min-width: 140px;
      min-height: 52px;
      pointer-events: auto;
    }

    .skip-popup i {
      font-size: 1.2rem;
    }

    .skip-popup.hidden {
      display: none;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .player-fallback {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #0a0d14;
      color: #8aa3cc;
      text-align: center;
      padding: 1.5rem;
      z-index: 10;
    }

    .player-fallback i {
      font-size: 3rem;
      color: #3d63ff;
      margin-bottom: 0.75rem;
    }

    .player-fallback.hidden {
      display: none;
    }

    .player-fallback button {
      min-width: 120px;
      min-height: 44px;
      background: #3d63ff;
      border: none;
      border-radius: 40px;
      color: white;
      font-weight: 600;
      margin-top: 1rem;
      padding: 0 1.5rem;
      cursor: pointer;
    }

    /* Episode header - mobile */
    .episode-header {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    #ep-title {
      font-size: 1.1rem;
      font-weight: 600;
      line-height: 1.3;
    }

    .nav-controls {
      display: flex;
      gap: 0.5rem;
      width: 100%;
    }

    .nav-btn {
      flex: 1;
      background: #1a253c;
      color: #fff;
      border: 1px solid #2e426b;
      border-radius: 40px;
      padding: 0.7rem 0.25rem;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: 0.2s;
      min-height: 44px;
    }

    .nav-btn:active {
      background: #2a3d67;
      transform: scale(0.98);
    }

    .nav-btn:disabled {
      opacity: 0.3;
      pointer-events: none;
    }

    /* Anime Info - mobile */
    .anime-info-container {
      background: linear-gradient(145deg, #121e2f, #0b111e);
      border-radius: 16px;
      padding: 1rem;
      margin-bottom: 0.75rem;
      border: 1px solid #2e3d5a;
    }

    .anime-name {
      font-size: 1.2rem;
      font-weight: 700;
      color: white;
      margin-bottom: 0.5rem;
      text-transform: capitalize;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .anime-name i {
      color: #3d63ff;
      font-size: 1.1rem;
    }

    .episode-details {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .detail-item {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-size: 0.9rem;
    }

    .detail-label {
      color: #8aa3cc;
      font-weight: 500;
      min-width: 40px;
    }

    .detail-value {
      color: white;
      font-weight: 500;
      word-break: break-word;
    }

    .episode-title-jp {
      color: #a5b9e2;
      font-size: 0.85rem;
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px dashed #2e426b;
      font-style: italic;
    }

    #introInfo {
      margin-top: 8px;
      font-size: 0.85rem;
      color: #3d63ff;
    }

    /* Servers section - mobile */
    .section {
      background: #121c2b;
      border-radius: 16px;
      padding: 0.75rem;
      border: 1px solid #253553;
      margin-bottom: 0.75rem;
    }

    .section h2 {
      font-size: 1rem;
      color: #cdd8ff;
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .server-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .server-btn {
      background: #1a253c;
      color: #cce1ff;
      border: 1px solid #2e426b;
      border-radius: 40px;
      padding: 10px 16px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      flex: 1 0 auto;
      max-width: fit-content;
      min-height: 44px;
      transition: 0.2s;
    }

    .server-btn:active {
      background: #25365c;
    }

    .server-btn.active {
      background: #3d63ff;
      border-color: #3d63ff;
    }

    /* Episodes section - mobile optimized */
    .episodes-header {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .episodes-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .episodes-title h2 {
      font-size: 1rem;
      color: #cdd8ff;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #episode-count {
      color: #8aa3cc;
      font-size: 0.85rem;
    }

    .episode-search {
      position: relative;
      width: 100%;
    }

    .episode-search input {
      width: 100%;
      padding: 12px 16px 12px 40px;
      background: #1a253c;
      border: 1px solid #2e426b;
      border-radius: 40px;
      color: white;
      font-size: 0.95rem;
      min-height: 44px;
    }

    .episode-search input:focus {
      outline: none;
      border-color: #3d63ff;
    }

    .episode-search i {
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      color: #8aa3cc;
      font-size: 1rem;
    }

    .episode-search .clear-search {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: #8aa3cc;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 8px 12px;
      display: none;
      min-width: 44px;
      min-height: 44px;
    }

    .episode-search .clear-search.visible {
      display: block;
    }

    /* Episodes grid - touch optimized */
    .episodes-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(55px, 1fr));
      gap: 5px;
      max-height: 280px;
      overflow-y: auto;
      padding: 4px 2px;
      -webkit-overflow-scrolling: touch;
    }

    .ep-btn {
      background: #1a253c;
      color: #cce1ff;
      border: 1px solid #2e426b;
      border-radius: 8px;
      padding: 12px 2px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      text-align: center;
      position: relative;
      transition: 0.2s;
      min-width: 0;
      min-height: 48px;
    }

    .ep-btn:active {
      background: #25365c;
      transform: scale(0.95);
    }

    .ep-btn.active {
      background: #3d63ff;
      border-color: #3d63ff;
    }

    .ep-btn.filler::after {
      content: "F";
      position: absolute;
      top: -2px;
      right: -2px;
      background: #ff6b6b;
      color: #000;
      font-size: 0.55rem;
      font-weight: bold;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #121c2b;
    }

    .ep-btn.watched::before {
      content: "‚úì";
      position: absolute;
      top: -2px;
      left: -2px;
      background: #4caf50;
      color: white;
      font-size: 0.55rem;
      font-weight: bold;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #121c2b;
    }

    .no-results {
      grid-column: 1 / -1;
      text-align: center;
      padding: 2rem;
      color: #8aa3cc;
    }

    .loading {
      text-align: center;
      padding: 2rem;
      color: #8aa3cc;
    }

    .error-message {
      text-align: center;
      padding: 1rem;
      color: #ff6b6b;
      background: #2a1a1a;
      border-radius: 12px;
    }

    /* Tablet adjustments */
    @media (min-width: 768px) {
      header {
        padding: 0.75rem 1.5rem;
      }

      #anime-title {
        font-size: 1.1rem;
      }

      .container {
        padding: 1.5rem;
      }

      .episode-header {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }

      #ep-title {
        font-size: 1.5rem;
      }

      .nav-controls {
        width: auto;
      }

      .nav-btn {
        flex: none;
        padding: 0.7rem 2rem;
        min-width: 120px;
      }

      .episodes-header {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }

      .episode-search {
        width: 280px;
      }

      .episodes-grid {
        grid-template-columns: repeat(auto-fill, minmax(65px, 1fr));
        max-height: 350px;
      }

      .anime-info-container {
        padding: 1.25rem;
      }

      .anime-name {
        font-size: 1.5rem;
      }
    }

    /* Scrollbar styling */
    .episodes-grid::-webkit-scrollbar {
      width: 4px;
    }

    .episodes-grid::-webkit-scrollbar-track {
      background: #1a253c;
      border-radius: 10px;
    }

    .episodes-grid::-webkit-scrollbar-thumb {
      background: #3d63ff;
      border-radius: 10px;
    }
  </style>
</head>
<body>

<header>
  <a href="javascript:history.back()">
    <i class="fas fa-arrow-left"></i>
  </a>
  <span id="anime-title">Loading...</span>
  <a href="/"><i class="fas fa-home"></i></a>
</header>

<div class="container">
  <div class="player-wrapper" id="playerWrapper">
    <!-- HLS Player (only mode) -->
    <video-js id="hls-player" class="video-js" controls preload="auto" data-setup='{"fluid": true, "controls": true, "autoplay": false, "preload": "auto"}'>
      <p class="vjs-no-js">Please enable JavaScript</p>
    </video-js>

    <!-- Quality Selector (custom) -->
    <div class="quality-selector" id="qualitySelector" style="display: none;">
      <button class="quality-btn" onclick="toggleQualityMenu()">
        <i class="fas fa-hd"></i> <span id="currentQuality">Auto</span>
      </button>
      <div class="quality-menu" id="qualityMenu">
        <div class="quality-menu-header">
          <span>Select Quality</span>
          <button onclick="toggleQualityMenu()"><i class="fas fa-times"></i></button>
        </div>
        <div class="quality-options" id="qualityOptions"></div>
      </div>
    </div>

    <!-- Skip Popup -->
    <div id="skipPopup" class="skip-popup hidden" onclick="skipIntro()">
      <i class="fas fa-forward"></i>
      <span>Skip Intro</span>
    </div>

    <div id="playerFallback" class="player-fallback hidden">
      <i class="fas fa-exclamation-triangle"></i>
      <h3>Video Not Loading</h3>
      <p>Try selecting a different server below</p>
      <button onclick="retryCurrentServer()">
        <i class="fas fa-redo"></i> Retry Current
      </button>
    </div>
  </div>

  <div class="episode-header">
    <h1 id="ep-title">Episode 1</h1>
    <div class="nav-controls">
      <button class="nav-btn" id="prevEp" disabled>
        <i class="fas fa-chevron-left"></i> Prev
      </button>
      <button class="nav-btn" id="nextEp">
        Next <i class="fas fa-chevron-right"></i>
      </button>
    </div>
  </div>

  <!-- Anime Info Container -->
  <div class="anime-info-container" id="animeInfoContainer">
    <div class="anime-name">
      <i class="fas fa-film"></i>
      <span id="animeDisplayName">One Piece</span>
    </div>
    <div class="episode-details">
      <div class="detail-item">
        <span class="detail-label">EP:</span>
        <span class="detail-value" id="currentEpNumber">1</span>
      </div>
      <div class="detail-item">
        <span class="detail-label">Title:</span>
        <span class="detail-value" id="currentEpTitle">Loading...</span>
      </div>
    </div>
    <div class="episode-title-jp" id="currentEpJpTitle"></div>
    <div id="introInfo"></div>
    <div id="continueWatching" class="continue-watching hidden">
      <i class="fas fa-clock"></i> Continue from <span id="continueTime">0:00</span>
      <button onclick="continueWatching()" class="continue-btn">Resume</button>
    </div>
  </div>

  <div class="section">
    <h2><i class="fas fa-server"></i> Available Servers</h2>
    <div class="server-grid" id="server-list">
      <div class="loading">Loading servers...</div>
    </div>
  </div>

  <div class="section">
    <div class="episodes-header">
      <div class="episodes-title">
        <h2><i class="fas fa-list"></i> Episodes</h2>
        <span id="episode-count"></span>
      </div>
      <div class="episode-search">
        <i class="fas fa-search"></i>
        <input type="text" id="episodeSearch" placeholder="Search episode...">
        <button class="clear-search" id="clearSearch"><i class="fas fa-times"></i></button>
      </div>
    </div>
    <div class="episodes-grid" id="episodes-grid">
      <div class="loading">Loading episodes...</div>
    </div>
  </div>
</div>

<!-- Add this CSS for quality selector -->
<style>
  .quality-selector {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 100;
  }

  .quality-btn {
    background: rgba(0, 0, 0, 0.7);
    color: white;
    border: 1px solid #3d63ff;
    border-radius: 20px;
    padding: 8px 16px;
    font-size: 0.9rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    backdrop-filter: blur(5px);
    min-height: 40px;
  }

  .quality-menu {
    position: absolute;
    top: 50px;
    right: 0;
    background: #121c2b;
    border: 1px solid #2e426b;
    border-radius: 12px;
    width: 200px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    display: none;
    z-index: 1000;
  }

  .quality-menu.show {
    display: block;
  }

  .quality-menu-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid #2e426b;
    color: white;
    font-weight: 600;
  }

  .quality-menu-header button {
    background: none;
    border: none;
    color: #8aa3cc;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 4px 8px;
  }

  .quality-options {
    padding: 8px;
  }

  .quality-option {
    padding: 10px 12px;
    color: #cce1ff;
    cursor: pointer;
    border-radius: 8px;
    transition: 0.2s;
    font-size: 0.9rem;
  }

  .quality-option:hover {
    background: #1a253c;
  }

  .quality-option.active {
    background: #3d63ff;
    color: white;
  }

  .continue-watching {
    margin-top: 10px;
    padding: 10px;
    background: rgba(61, 99, 255, 0.2);
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.9rem;
    border: 1px solid #3d63ff;
  }

  .continue-watching.hidden {
    display: none;
  }

  .continue-btn {
    background: #3d63ff;
    color: white;
    border: none;
    border-radius: 20px;
    padding: 6px 16px;
    font-size: 0.85rem;
    font-weight: 500;
    cursor: pointer;
    margin-left: auto;
  }
</style>

<!-- Scripts -->
<script src="https://vjs.zencdn.net/8.10.0/video.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/videojs-contrib-hls@5.15.0/dist/videojs-contrib-hls.min.js"></script>

<script>
// Configuration
const API_BASE = (() => {
    const hostname = window.location.hostname;
    const protocol = window.location.protocol;
    const port = window.location.port;
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return `${protocol}//${hostname}${port ? ':' + port : ''}/api`;
    }
    return '/api';
})();

const PROXY_BASE = 'https://m3u8proxy-six-omega.vercel.app/m3u8-proxy?url=';

const params = new URLSearchParams(location.search);
const animeId = params.get("id") || "one-piece-100";
const urlEpisodeId = params.get("ep") || "";
const hlsPlayer = document.getElementById("hls-player");
const playerFallback = document.getElementById("playerFallback");
const skipPopup = document.getElementById("skipPopup");
const qualitySelector = document.getElementById("qualitySelector");
const qualityMenu = document.getElementById("qualityMenu");
const qualityOptions = document.getElementById("qualityOptions");
const currentQualitySpan = document.getElementById("currentQuality");

let episodesList = [];
let filteredEpisodes = [];
let currentEpIndex = 0;
let currentServer = "hd-2";
let currentType = "sub";
let watchHistory = JSON.parse(localStorage.getItem(`watch_${animeId}`)) || [];
let videoPlayer = null;
let introStart = null;
let introEnd = null;
let skipTimeout = null;
let isLoading = false;
let availableQualities = [];
let currentQuality = 'auto';
let playProgress = JSON.parse(localStorage.getItem(`progress_${animeId}`)) || {};

// Initialize video.js player (HLS only)
function initHlsPlayer() {
    if (!videoPlayer) {
        videoPlayer = videojs('hls-player', {
            controls: true,
            autoplay: false,
            preload: 'auto',
            html5: {
                hls: {
                    enableLowInitialPlaylist: true,
                    smoothQualityChange: true,
                    overrideNative: true,
                    handleManifestRedirects: true
                }
            },
            playbackRates: [0.5, 1, 1.25, 1.5, 2],
            userActions: {
                hotkeys: true
            }
        });

        // Track time for skip detection and progress
        videoPlayer.on('timeupdate', () => {
            if (!videoPlayer.currentTime) return;
            
            const currentTime = videoPlayer.currentTime();
            const duration = videoPlayer.duration();
            
            // Skip detection
            if (introStart && introEnd) {
                if (currentTime >= introStart && currentTime <= introStart + 5) {
                    showSkipPopup();
                }
                if (currentTime > introEnd) {
                    hideSkipPopup();
                }
            }
            
            // Save progress every 30 seconds
            if (currentTime > 0 && duration > 0 && currentTime % 30 < 1) {
                saveProgress(currentEpIndex, currentTime);
            }
        });

        // Save progress on pause
        videoPlayer.on('pause', () => {
            if (videoPlayer.currentTime() > 0) {
                saveProgress(currentEpIndex, videoPlayer.currentTime());
            }
        });

        // Auto landscape on fullscreen for mobile
        videoPlayer.on('fullscreenchange', () => {
            if (videoPlayer.isFullscreen()) {
                if (screen.orientation && screen.orientation.lock) {
                    screen.orientation.lock('landscape').catch(e => console.log('Orientation lock failed:', e));
                }
            }
        });

        // Error handling
        videoPlayer.on('error', () => {
            console.error('Video.js error:', videoPlayer.error());
            if (!isLoading) {
                playerFallback.classList.remove('hidden');
            }
        });

        // Success handling
        videoPlayer.on('loadedmetadata', () => {
            playerFallback.classList.add('hidden');
            isLoading = false;
            
            // Extract available qualities from HLS manifest
            detectQualities();
            
            // Check for continue watching
            checkContinueWatching();
        });

        // Quality change handler
        videoPlayer.on('qualitychange', (event, quality) => {
            currentQuality = quality.height || 'auto';
            currentQualitySpan.textContent = formatQualityName(currentQuality);
        });
    }
    return videoPlayer;
}

// Save watch progress
function saveProgress(episodeIndex, time) {
    if (!episodesList[episodeIndex]) return;
    
    const ep = episodesList[episodeIndex];
    const epId = ep.data_id || ep.id;
    
    playProgress[epId] = {
        time: Math.floor(time),
        episode_no: ep.episode_no,
        timestamp: Date.now()
    };
    
    localStorage.setItem(`progress_${animeId}`, JSON.stringify(playProgress));
}

// Check if current episode has saved progress
function checkContinueWatching() {
    const currentEp = episodesList[currentEpIndex];
    if (!currentEp) return;
    
    const epId = currentEp.data_id || currentEp.id;
    const progress = playProgress[epId];
    
    const continueDiv = document.getElementById('continueWatching');
    
    if (progress && progress.time > 10 && videoPlayer.duration() && progress.time < videoPlayer.duration() - 10) {
        const minutes = Math.floor(progress.time / 60);
        const seconds = progress.time % 60;
        document.getElementById('continueTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        continueDiv.classList.remove('hidden');
    } else {
        continueDiv.classList.add('hidden');
    }
}

// Continue watching from saved position
function continueWatching() {
    const currentEp = episodesList[currentEpIndex];
    if (!currentEp) return;
    
    const epId = currentEp.data_id || currentEp.id;
    const progress = playProgress[epId];
    
    if (progress && videoPlayer) {
        videoPlayer.currentTime(progress.time);
        document.getElementById('continueWatching').classList.add('hidden');
    }
}

// Detect qualities from HLS stream
function detectQualities() {
    if (!videoPlayer || !videoPlayer.tech_) return;
    
    try {
        const hls = videoPlayer.tech_.hls;
        if (hls && hls.levels && hls.levels.length > 0) {
            availableQualities = hls.levels.map(level => ({
                height: level.height,
                bitrate: level.bitrate,
                label: level.height ? `${level.height}p` : 'Auto'
            }));
            
            // Add auto option
            availableQualities.unshift({ height: 'auto', label: 'Auto' });
            
            renderQualityOptions();
            qualitySelector.style.display = 'block';
        }
    } catch (e) {
        console.log('Could not detect qualities:', e);
    }
}

// Render quality options
function renderQualityOptions() {
    qualityOptions.innerHTML = availableQualities.map(q => `
        <div class="quality-option ${currentQuality === q.height ? 'active' : ''}" 
             onclick="setQuality('${q.height}')">
            ${q.label}
        </div>
    `).join('');
}

// Set video quality
function setQuality(height) {
    if (!videoPlayer || !videoPlayer.tech_) return;
    
    try {
        const hls = videoPlayer.tech_.hls;
        if (hls && hls.levels) {
            if (height === 'auto') {
                hls.currentLevel = -1; // Auto
                currentQuality = 'auto';
            } else {
                const levelIndex = hls.levels.findIndex(l => l.height === parseInt(height));
                if (levelIndex !== -1) {
                    hls.currentLevel = levelIndex;
                    currentQuality = height;
                }
            }
            
            currentQualitySpan.textContent = formatQualityName(currentQuality);
            renderQualityOptions();
            toggleQualityMenu();
        }
    } catch (e) {
        console.log('Could not set quality:', e);
    }
}

// Format quality name for display
function formatQualityName(quality) {
    if (quality === 'auto') return 'Auto';
    return quality + 'p';
}

// Toggle quality menu
function toggleQualityMenu() {
    qualityMenu.classList.toggle('show');
}

// Skip popup functions
function showSkipPopup() {
    if (!skipPopup.classList.contains('hidden')) return;
    skipPopup.classList.remove('hidden');
    
    if (skipTimeout) clearTimeout(skipTimeout);
    skipTimeout = setTimeout(() => {
        hideSkipPopup();
    }, 8000);
}

function hideSkipPopup() {
    skipPopup.classList.add('hidden');
    if (skipTimeout) {
        clearTimeout(skipTimeout);
        skipTimeout = null;
    }
}

function skipIntro() {
    if (introEnd && videoPlayer) {
        videoPlayer.currentTime(introEnd);
        hideSkipPopup();
    }
}

function formatTitle(id) {
    return id.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
}

function updateURL(epId) {
    const url = new URL(window.location);
    url.searchParams.set('id', animeId);
    url.searchParams.set('ep', epId);
    window.history.replaceState({}, '', url);
}

function markAsWatched(episodeNo) {
    if (!watchHistory.includes(episodeNo)) {
        watchHistory.push(episodeNo);
        localStorage.setItem(`watch_${animeId}`, JSON.stringify(watchHistory));
    }
}

function isWatched(episodeNo) {
    return watchHistory.includes(episodeNo);
}

// Load stream with HLS only
async function loadStream(epId, server = currentServer, type = currentType) {
    if (isLoading) return;
    
    try {
        isLoading = true;
        playerFallback.classList.add('hidden');
        
        if (videoPlayer) {
            videoPlayer.src({ type: 'application/x-mpegURL', src: '' });
        }
        
        hideSkipPopup();

        currentServer = server;
        currentType = type;

        const streamUrl = `${API_BASE}/stream?id=${animeId}?ep=${epId}&server=${server}&type=${type}`;
        console.log('üì° Loading HLS stream from:', streamUrl);

        const res = await fetch(streamUrl);
        const json = await res.json();

        if (!json.success) throw new Error("Stream not found");

        const stream = json.results.streamingLink;
        
        // Store intro/outro for skip detection
        introStart = stream.intro?.start;
        introEnd = stream.intro?.end;
        
        if (introStart && introEnd) {
            document.getElementById('introInfo').innerHTML = 
                `<i class="fas fa-clock"></i> Intro: ${introStart}s - ${introEnd}s`;
        } else {
            document.getElementById('introInfo').innerHTML = '';
        }

        // HLS only mode
        if (stream.link && stream.link.file) {
            const hlsUrl = stream.link.file;
            const proxyUrl = PROXY_BASE + encodeURIComponent(hlsUrl);
            
            initHlsPlayer();
            videoPlayer.src({ type: 'application/x-mpegURL', src: proxyUrl });
            
            // Add subtitles with English as default
            if (stream.tracks && stream.tracks.length > 0) {
                // Remove old tracks
                if (videoPlayer.remoteTextTracks) {
                    const tracks = videoPlayer.remoteTextTracks();
                    for (let i = tracks.length - 1; i >= 0; i--) {
                        videoPlayer.removeRemoteTextTrack(tracks[i]);
                    }
                }
                
                // Find English subtitles
                const englishTracks = stream.tracks.filter(track => 
                    (track.language === 'en' || track.label?.toLowerCase().includes('english')) &&
                    (track.kind === 'captions' || track.kind === 'subtitles')
                );
                
                // Add all tracks but set English as default
                stream.tracks.forEach(track => {
                    if (track.kind === 'captions' || track.kind === 'subtitles') {
                        const isEnglish = englishTracks.includes(track);
                        videoPlayer.addRemoteTextTrack({
                            kind: 'captions',
                            label: track.label || (track.language === 'en' ? 'English' : track.language),
                            language: track.language || 'en',
                            src: track.file,
                            default: isEnglish // Auto-select English
                        }, false);
                    }
                });
                
                // Log which tracks were added
                console.log('Added subtitles:', stream.tracks.length, 'English tracks:', englishTracks.length);
            }
            
            videoPlayer.play().catch(e => {
                console.log('Autoplay prevented:', e);
            });
        } else {
            throw new Error("No HLS stream available");
        }

        renderServers(json.results.servers, epId);
        isLoading = false;

    } catch (e) {
        console.error('‚ùå Stream error:', e);
        playerFallback.classList.remove('hidden');
        isLoading = false;
    }
}

function retryCurrentServer() {
    const ep = episodesList[currentEpIndex];
    if (ep) {
        playerFallback.classList.add('hidden');
        loadStream(ep.data_id || ep.id, currentServer, currentType);
    }
}

function renderServers(servers, epId) {
    const container = document.getElementById("server-list");
    if (!servers?.length) {
        container.innerHTML = "<p style='color:#8aa3cc'>üìå No alternative servers</p>";
        return;
    }
    
    container.innerHTML = servers.map(s => {
        const serverName = s.serverName.toLowerCase();
        const isActive = serverName === currentServer && s.type === currentType;
        return `
            <button class="server-btn ${isActive ? 'active' : ''}" 
                    onclick="loadStream('${epId}', '${serverName}', '${s.type}')"
                    data-server="${serverName}"
                    data-type="${s.type}">
                <span>${s.serverName}</span>
                <span style="font-size:0.7rem; opacity:0.8">(${s.type})</span>
            </button>
        `;
    }).join("");
}

async function loadEpisodes() {
    try {
        const episodesUrl = `${API_BASE}/episodes/${animeId}`;
        const res = await fetch(episodesUrl);
        const json = await res.json();

        if (!json.success) throw new Error("No episodes found");

        episodesList = json.results.episodes;
        filteredEpisodes = [...episodesList];
        document.getElementById("episode-count").textContent = `${episodesList.length} total`;
        document.getElementById("anime-title").textContent = formatTitle(animeId);

        // Check for last watched episode
        const lastWatched = getLastWatchedEpisode();
        
        if (urlEpisodeId) {
            currentEpIndex = episodesList.findIndex(ep => ep.id === urlEpisodeId || ep.data_id === urlEpisodeId);
        } else if (lastWatched !== null) {
            currentEpIndex = lastWatched;
        }
        
        if (currentEpIndex === -1) currentEpIndex = 0;

        renderEpisodes();

        const currentEp = episodesList[currentEpIndex];
        if (currentEp) {
            updateAnimeInfoContainer(currentEp);
            loadStream(currentEp.data_id || currentEp.id);
        }

        // Setup search
        const searchInput = document.getElementById('episodeSearch');
        const clearBtn = document.getElementById('clearSearch');

        searchInput.addEventListener('input', handleSearch);
        clearBtn.addEventListener('click', () => {
            searchInput.value = '';
            clearBtn.classList.remove('visible');
            filteredEpisodes = [...episodesList];
            renderEpisodes();
        });

    } catch (e) {
        console.error('‚ùå Failed to load episodes:', e);
        document.getElementById("episodes-grid").innerHTML = `
            <div class="error-message">
                <i class="fas fa-exclamation-triangle"></i> 
                Failed to load episodes
            </div>
        `;
    }
}

// Get last watched episode from progress
function getLastWatchedEpisode() {
    const progresses = Object.entries(playProgress);
    if (progresses.length === 0) return null;
    
    // Find most recent
    let latest = null;
    let latestIndex = null;
    
    progresses.forEach(([epId, data]) => {
        const index = episodesList.findIndex(ep => (ep.data_id || ep.id) === epId);
        if (index !== -1 && (!latest || data.timestamp > latest.timestamp)) {
            latest = data;
            latestIndex = index;
        }
    });
    
    return latestIndex;
}

function handleSearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim();
    const clearBtn = document.getElementById('clearSearch');
    
    if (searchTerm) {
        clearBtn.classList.add('visible');
        filteredEpisodes = episodesList.filter(ep => 
            ep.episode_no.toString().includes(searchTerm) ||
            (ep.title && ep.title.toLowerCase().includes(searchTerm)) ||
            (ep.japanese_title && ep.japanese_title.toLowerCase().includes(searchTerm))
        );
    } else {
        clearBtn.classList.remove('visible');
        filteredEpisodes = [...episodesList];
    }
    
    renderEpisodes();
}

function renderEpisodes() {
    const grid = document.getElementById("episodes-grid");
    
    if (filteredEpisodes.length === 0) {
        grid.innerHTML = '<div class="no-results"><i class="fas fa-search"></i> No episodes found</div>';
        return;
    }
    
    grid.innerHTML = filteredEpisodes.map((ep, i) => {
        const epId = ep.data_id || ep.id;
        const originalIndex = episodesList.findIndex(e => (e.data_id || e.id) === epId);
        const isActive = originalIndex === currentEpIndex;
        const fillerClass = ep.filler ? 'filler' : '';
        const watchedClass = isWatched(ep.episode_no) ? 'watched' : '';
        const hasProgress = playProgress[epId] ? 'has-progress' : '';
        
        return `
            <button class="ep-btn ${fillerClass} ${watchedClass} ${hasProgress} ${isActive ? 'active' : ''}" 
                    onclick="changeEpisode(${originalIndex})"
                    title="${ep.title || ''}">
                ${ep.episode_no}
                ${playProgress[epId] ? '<span class="progress-dot"></span>' : ''}
            </button>
        `;
    }).join("");
    
    updateNavButtons();
}

function updateAnimeInfoContainer(ep) {
    document.getElementById('animeDisplayName').textContent = formatTitle(animeId);
    document.getElementById('currentEpNumber').textContent = ep.episode_no;
    document.getElementById('currentEpTitle').textContent = ep.title || `Episode ${ep.episode_no}`;
    document.getElementById('currentEpJpTitle').textContent = ep.japanese_title || '';
    document.getElementById("ep-title").textContent = `Episode ${ep.episode_no}`;
    
    markAsWatched(ep.episode_no);
    checkContinueWatching();
}

function changeEpisode(index) {
    if (!episodesList[index] || index === currentEpIndex || isLoading) return;
    
    const ep = episodesList[index];
    currentEpIndex = index;
    
    updateURL(ep.data_id || ep.id);
    renderEpisodes();
    updateAnimeInfoContainer(ep);
    loadStream(ep.data_id || ep.id, currentServer, currentType);
    
    document.getElementById('episodeSearch').value = '';
    document.getElementById('clearSearch').classList.remove('visible');
    filteredEpisodes = [...episodesList];
    hideSkipPopup();
    
    // Hide quality menu when changing episode
    qualityMenu.classList.remove('show');
}

function updateNavButtons() {
    const prevBtn = document.getElementById("prevEp");
    const nextBtn = document.getElementById("nextEp");
    prevBtn.disabled = currentEpIndex === 0 || isLoading;
    nextBtn.disabled = currentEpIndex === episodesList.length - 1 || isLoading;
}

// Navigation
document.getElementById("prevEp").onclick = () => {
    if (currentEpIndex > 0) changeEpisode(currentEpIndex - 1);
};

document.getElementById("nextEp").onclick = () => {
    if (currentEpIndex < episodesList.length - 1) changeEpisode(currentEpIndex + 1);
};

// Close quality menu when clicking outside
document.addEventListener('click', (e) => {
    if (!qualitySelector.contains(e.target) && qualityMenu.classList.contains('show')) {
        qualityMenu.classList.remove('show');
    }
});

// Make functions global
window.retryCurrentServer = retryCurrentServer;
window.skipIntro = skipIntro;
window.loadStream = loadStream;
window.toggleQualityMenu = toggleQualityMenu;
window.setQuality = setQuality;
window.continueWatching = continueWatching;

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    loadEpisodes();
    
    // Prevent zoom on double tap
    document.addEventListener('touchstart', (e) => {
        if (e.touches.length > 1) {
            e.preventDefault();
        }
    }, { passive: false });
    
    // Handle orientation changes
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            if (videoPlayer && videoPlayer.isFullscreen()) {
                // Adjust fullscreen on orientation change
            }
        }, 100);
    });
});
</script>
</body>
</html>