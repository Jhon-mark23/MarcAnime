<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes" />
  <title>ZenStream ¬∑ Watch Anime</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0d14;
      color: #e5eaff;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      line-height: 1.5;
      min-height: 100vh;
    }

    /* Mobile-first header */
    header {
      background: rgba(18, 26, 40, 0.98);
      backdrop-filter: blur(10px);
      padding: 0.8rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #1f2940;
      position: sticky;
      top: 0;
      z-index: 100;
      gap: 0.5rem;
    }

    header a {
      color: #9ab3ff;
      text-decoration: none;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: #1a253c;
      border-radius: 40px;
      font-size: 0.9rem;
      white-space: nowrap;
    }

    #anime-title {
      font-size: 1rem;
      font-weight: 600;
      text-transform: capitalize;
      background: linear-gradient(135deg, #fff, #9ab3ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 40vw;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

    /* Player section */
    .player-wrapper {
      background: #000;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.8);
      border: 1px solid #253553;
      margin-bottom: 1rem;
      aspect-ratio: 16/9;
    }

    iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Episode header with title and nav */
    .episode-header {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      margin-bottom: 1rem;
    }

    #ep-title {
      font-size: 1.3rem;
      font-weight: 600;
      line-height: 1.3;
    }

    .nav-controls {
      display: flex;
      gap: 0.5rem;
      width: 100%;
    }

    .nav-btn {
      flex: 1;
      background: #1a253c;
      color: #fff;
      border: 1px solid #2e426b;
      border-radius: 40px;
      padding: 0.8rem 0.5rem;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: 0.2s;
    }

    .nav-btn:active {
      background: #2a3d67;
      transform: scale(0.98);
    }

    .nav-btn:disabled {
      opacity: 0.3;
      pointer-events: none;
    }

    /* Episode info card */
    .episode-info {
      background: #121c2b;
      border-radius: 16px;
      padding: 1rem;
      margin-bottom: 1rem;
      border: 1px solid #253553;
      font-size: 0.9rem;
    }

    .episode-info p {
      color: #9ab3ff;
      word-break: break-word;
    }

    .episode-info strong {
      color: white;
    }

    /* Servers section */
    .section {
      background: #121c2b;
      border-radius: 16px;
      padding: 1rem;
      border: 1px solid #253553;
      margin-bottom: 1rem;
    }

    .section h2 {
      font-size: 1.1rem;
      color: #cdd8ff;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .server-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .server-btn {
      background: #1a253c;
      color: #cce1ff;
      border: 1px solid #2e426b;
      border-radius: 40px;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      flex: 1 0 auto;
      max-width: fit-content;
      transition: 0.2s;
    }

    .server-btn:active {
      background: #25365c;
    }

    .server-btn.active {
      background: #3d63ff;
      border-color: #3d63ff;
    }

    /* Episodes section with search */
    .episodes-header {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      margin-bottom: 1rem;
    }

    .episodes-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .episodes-title h2 {
      font-size: 1.1rem;
      color: #cdd8ff;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #episode-count {
      color: #8aa3cc;
      font-size: 0.9rem;
    }

    /* Search box inside episodes */
    .episode-search {
      position: relative;
      width: 100%;
    }

    .episode-search input {
      width: 100%;
      padding: 12px 16px 12px 40px;
      background: #1a253c;
      border: 1px solid #2e426b;
      border-radius: 40px;
      color: white;
      font-size: 0.95rem;
    }

    .episode-search input:focus {
      outline: none;
      border-color: #3d63ff;
    }

    .episode-search i {
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      color: #8aa3cc;
      font-size: 1rem;
    }

    .episode-search .clear-search {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: #8aa3cc;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 4px 8px;
      display: none;
    }

    .episode-search .clear-search.visible {
      display: block;
    }

    /* Episodes grid */
    .episodes-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 6px;
      max-height: 350px;
      overflow-y: auto;
      padding: 5px 2px;
    }

    .ep-btn {
      background: #1a253c;
      color: #cce1ff;
      border: 1px solid #2e426b;
      border-radius: 8px;
      padding: 10px 4px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      text-align: center;
      position: relative;
      transition: 0.2s;
      min-width: 0;
    }

    .ep-btn:active {
      background: #25365c;
      transform: scale(0.95);
    }

    .ep-btn.active {
      background: #3d63ff;
      border-color: #3d63ff;
    }

    .ep-btn.filler::after {
      content: "F";
      position: absolute;
      top: -3px;
      right: -3px;
      background: #ff6b6b;
      color: #000;
      font-size: 0.6rem;
      font-weight: bold;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #121c2b;
    }

    .ep-btn.watched::before {
      content: "‚úì";
      position: absolute;
      top: -3px;
      left: -3px;
      background: #4caf50;
      color: white;
      font-size: 0.6rem;
      font-weight: bold;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #121c2b;
    }

    .no-results {
      grid-column: 1 / -1;
      text-align: center;
      padding: 2rem;
      color: #8aa3cc;
    }

    .loading {
      text-align: center;
      padding: 2rem;
      color: #8aa3cc;
    }

    .error-message {
      text-align: center;
      padding: 1rem;
      color: #ff6b6b;
      background: #2a1a1a;
      border-radius: 12px;
    }

    /* Tablet and up */
    @media (min-width: 768px) {
      header {
        padding: 1rem 2rem;
      }

      #anime-title {
        font-size: 1.2rem;
        max-width: none;
      }

      .container {
        padding: 2rem;
      }

      .episode-header {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }

      #ep-title {
        font-size: 1.8rem;
      }

      .nav-controls {
        width: auto;
      }

      .nav-btn {
        flex: none;
        padding: 0.7rem 1.8rem;
      }

      .episodes-header {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }

      .episode-search {
        width: 300px;
      }

      .episodes-grid {
        grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
        max-height: 400px;
      }
    }

    /* Custom scrollbar */
    .episodes-grid::-webkit-scrollbar {
      width: 5px;
    }

    .episodes-grid::-webkit-scrollbar-track {
      background: #1a253c;
      border-radius: 10px;
    }

    .episodes-grid::-webkit-scrollbar-thumb {
      background: #3d63ff;
      border-radius: 10px;
    }
  </style>
</head>
<body>

<header>
  <a href="javascript:history.back()">
    <i class="fas fa-arrow-left"></i> Back
  </a>
  <span id="anime-title">Loading...</span>
  <a href="index.html"><i class="fas fa-home"></i></a>
</header>

<div class="container">
  <div class="player-wrapper">
    <iframe id="iframe-player" allowfullscreen allow="autoplay; fullscreen; encrypted-media; picture-in-picture"></iframe>
  </div>

  <div class="episode-header">
    <h1 id="ep-title">Episode 1</h1>
    <div class="nav-controls">
      <button class="nav-btn" id="prevEp" disabled>
        <i class="fas fa-chevron-left"></i> Prev
      </button>
      <button class="nav-btn" id="nextEp">
        Next <i class="fas fa-chevron-right"></i>
      </button>
    </div>
  </div>

  <div class="episode-info" id="episode-info">
    <p><i class="fas fa-spinner fa-spin"></i> Loading episode information...</p>
  </div>

  <div class="section">
    <h2><i class="fas fa-server"></i> Available Servers</h2>
    <div class="server-grid" id="server-list">
      <div class="loading">Loading servers...</div>
    </div>
  </div>

  <div class="section">
    <div class="episodes-header">
      <div class="episodes-title">
        <h2><i class="fas fa-list"></i> Episodes</h2>
        <span id="episode-count"></span>
      </div>
      <div class="episode-search">
        <i class="fas fa-search"></i>
        <input type="text" id="episodeSearch" placeholder="Search episode # or title...">
        <button class="clear-search" id="clearSearch"><i class="fas fa-times"></i></button>
      </div>
    </div>
    <div class="episodes-grid" id="episodes-grid">
      <div class="loading">Loading episodes...</div>
    </div>
  </div>
</div>

<script>
const API_BASE = "/api";
const params = new URLSearchParams(location.search);
const animeId = params.get("id");
const urlEpisodeId = params.get("ep");
const iframe = document.getElementById("iframe-player");

let episodesList = [];
let filteredEpisodes = [];
let currentEpIndex = 0;
let currentServer = "hd-1";
let currentType = "sub";
let watchHistory = JSON.parse(localStorage.getItem(`watch_${animeId}`)) || [];

// Helper functions
function formatTitle(id) {
  return id.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
}

function updateURL(epId) {
  const url = new URL(window.location);
  url.searchParams.set('id', animeId);
  url.searchParams.set('ep', epId);
  window.history.replaceState({}, '', url);
}

// Watch history
function markAsWatched(episodeNo) {
  if (!watchHistory.includes(episodeNo)) {
    watchHistory.push(episodeNo);
    localStorage.setItem(`watch_${animeId}`, JSON.stringify(watchHistory));
  }
}

function isWatched(episodeNo) {
  return watchHistory.includes(episodeNo);
}

// Load stream
async function loadStream(epId, server = currentServer, type = currentType) {
  try {
    currentServer = server;
    currentType = type;
    
    const streamUrl = `${API_BASE}/stream?id=${animeId}?ep=${epId}&server=${server}&type=${type}`;
    const res = await fetch(streamUrl);
    const json = await res.json();
    
    if (!json.success) throw new Error("Stream not found");
    
    const stream = json.results.streamingLink;
    iframe.src = stream.iframe || "about:blank";
    
    renderServers(json.results.servers, epId);
    
  } catch (e) {
    console.error(e);
    document.getElementById("server-list").innerHTML = `<div class="error-message">‚ö†Ô∏è Failed to load stream</div>`;
  }
}

// Render server buttons
function renderServers(servers, epId) {
  const container = document.getElementById("server-list");
  if (!servers?.length) {
    container.innerHTML = "<p style='color:#8aa3cc'>üìå No alternative servers available.</p>";
    return;
  }
  
  container.innerHTML = servers.map(s => {
    const serverName = s.serverName.toLowerCase();
    const isActive = serverName === currentServer && s.type === currentType;
    return `
      <button class="server-btn ${isActive ? 'active' : ''}" 
              onclick="loadStream('${epId}', '${serverName}', '${s.type}')"
              data-server="${serverName}"
              data-type="${s.type}">
        <span>${s.serverName}</span>
        <span style="font-size:0.7rem; opacity:0.8">(${s.type})</span>
      </button>
    `;
  }).join("");
}

// Load episodes
async function loadEpisodes() {
  try {
    const res = await fetch(`${API_BASE}/episodes/${animeId}`);
    const json = await res.json();
    
    if (!json.success) throw new Error("No episodes found");
    
    episodesList = json.results.episodes;
    filteredEpisodes = [...episodesList];
    document.getElementById("episode-count").textContent = `${episodesList.length} total`;
    document.getElementById("anime-title").textContent = formatTitle(animeId);
    
    // Find current episode index
    if (urlEpisodeId) {
      currentEpIndex = episodesList.findIndex(ep => ep.id === urlEpisodeId || ep.data_id === urlEpisodeId);
    }
    if (currentEpIndex === -1 || !urlEpisodeId) currentEpIndex = 0;
    
    renderEpisodes();
    
    // Load first/selected episode
    const currentEp = episodesList[currentEpIndex];
    if (currentEp) {
      updateEpisodeInfo(currentEp);
      loadStream(currentEp.data_id || currentEp.id);
    }
    
    // Setup search
    const searchInput = document.getElementById('episodeSearch');
    const clearBtn = document.getElementById('clearSearch');
    
    searchInput.addEventListener('input', handleSearch);
    clearBtn.addEventListener('click', () => {
      searchInput.value = '';
      clearBtn.classList.remove('visible');
      filteredEpisodes = [...episodesList];
      renderEpisodes();
    });
    
  } catch (e) {
    console.error(e);
    document.getElementById("episodes-grid").innerHTML = `<div class="error-message">‚ùå Failed to load episodes</div>`;
  }
}

// Search handler
function handleSearch(e) {
  const searchTerm = e.target.value.toLowerCase().trim();
  const clearBtn = document.getElementById('clearSearch');
  
  if (searchTerm) {
    clearBtn.classList.add('visible');
    filteredEpisodes = episodesList.filter(ep => 
      ep.episode_no.toString().includes(searchTerm) ||
      (ep.title && ep.title.toLowerCase().includes(searchTerm)) ||
      (ep.japanese_title && ep.japanese_title.toLowerCase().includes(searchTerm))
    );
  } else {
    clearBtn.classList.remove('visible');
    filteredEpisodes = [...episodesList];
  }
  
  renderEpisodes();
}

// Render episode buttons
function renderEpisodes() {
  const grid = document.getElementById("episodes-grid");
  
  if (filteredEpisodes.length === 0) {
    grid.innerHTML = '<div class="no-results"><i class="fas fa-search"></i> No episodes found</div>';
    return;
  }
  
  grid.innerHTML = filteredEpisodes.map((ep, i) => {
    const epId = ep.data_id || ep.id;
    const originalIndex = episodesList.findIndex(e => (e.data_id || e.id) === epId);
    const isActive = originalIndex === currentEpIndex;
    const fillerClass = ep.filler ? 'filler' : '';
    const watchedClass = isWatched(ep.episode_no) ? 'watched' : '';
    
    return `
      <button class="ep-btn ${fillerClass} ${watchedClass} ${isActive ? 'active' : ''}" 
              onclick="changeEpisode(${originalIndex})"
              title="${ep.title || ''}">
        ${ep.episode_no}
      </button>
    `;
  }).join("");
  
  updateNavButtons();
}

// Update episode info panel
function updateEpisodeInfo(ep) {
  const infoEl = document.getElementById("episode-info");
  const title = ep.title || `Episode ${ep.episode_no}`;
  const jpTitle = ep.japanese_title ? `¬∑ ${ep.japanese_title}` : '';
  const fillerBadge = ep.filler ? ' <span style="background:#ff6b6b; color:#000; padding:2px 8px; border-radius:12px; font-size:0.7rem; margin-left:6px;">FILLER</span>' : '';
  
  infoEl.innerHTML = `
    <p>
      <strong>EP ${ep.episode_no}:</strong> ${title} ${fillerBadge}
    </p>
  `;
  
  document.getElementById("ep-title").textContent = `Episode ${ep.episode_no}`;
  
  // Mark as watching
  markAsWatched(ep.episode_no);
}

// Handle episode change
function changeEpisode(index) {
  if (!episodesList[index] || index === currentEpIndex) return;
  
  const ep = episodesList[index];
  currentEpIndex = index;
  
  // Update URL
  updateURL(ep.data_id || ep.id);
  
  // Update UI
  renderEpisodes();
  updateEpisodeInfo(ep);
  
  // Load stream with current server/type
  loadStream(ep.data_id || ep.id, currentServer, currentType);
  
  // Clear search when changing episodes (optional)
  document.getElementById('episodeSearch').value = '';
  document.getElementById('clearSearch').classList.remove('visible');
  filteredEpisodes = [...episodesList];
}

// Update nav buttons
function updateNavButtons() {
  const prevBtn = document.getElementById("prevEp");
  const nextBtn = document.getElementById("nextEp");
  
  prevBtn.disabled = currentEpIndex === 0;
  nextBtn.disabled = currentEpIndex === episodesList.length - 1;
}

// Navigation
document.getElementById("prevEp").onclick = () => {
  if (currentEpIndex > 0) changeEpisode(currentEpIndex - 1);
};

document.getElementById("nextEp").onclick = () => {
  if (currentEpIndex < episodesList.length - 1) changeEpisode(currentEpIndex + 1);
};

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft' && !e.ctrlKey && !e.metaKey) {
    e.preventDefault();
    if (currentEpIndex > 0) changeEpisode(currentEpIndex - 1);
  } else if (e.key === 'ArrowRight' && !e.ctrlKey && !e.metaKey) {
    e.preventDefault();
    if (currentEpIndex < episodesList.length - 1) changeEpisode(currentEpIndex + 1);
  } else if (e.key === 'f' && e.ctrlKey) {
    e.preventDefault();
    document.getElementById('episodeSearch').focus();
  } else if (e.key === 'Escape') {
    document.getElementById('episodeSearch').blur();
  }
});

// Initialize
loadEpisodes();
</script>
</body>
</html>
